
#!/bin/bash													// header

. common.sh													// including other scripts

set -e														// immediate exit on error
set -u														// immediate exit on unset variable
set -x														// mirroring commands to stderr

echo "Hello"
echo 'Hello' > .gitignore									// write to file (overwrite)
echo 'Hello' >> .gitignore									// write to file (append)

find														// list folder structure
find . -not -path '*/\.*'									// structure without those starting with dot

printf "Hello\n"											// more consistent than echo, definitely supports newlines

VAR_MY="value_my"											// store value in variable
cd $VAR_PWD													// retrieve value from variable

VAR_PWD=$(pwd)												// store command result to variable
cd $VAR_PWD

$(($VAR_NUMBER - 1))										// arithmetic evaluation

echo $VAR_R

cp -r /source-folder /destination-folder					// recursive copy

mkdir -p src/main/resources/META-INF						// create folder with all the parents

rm file.txt
rm [file_prefix]*
rm -f file.txt												// forced - deletes write-protected file & silent when file does not exist
rm -rf folder												// delete folder recursively and forced

tail file.txt
tail -f file.txt
tail -1000 file.txt

[ -d "/path/dir/" ] && echo "exists"						// one line folder existence check

sudo lsof -i -P -n | grep LISTEN
sudo netstat -tulpn | grep LISTEN
sudo lsof -i:22 ## see a specific port such as 22 ##
sudo nmap -sTU -O IP-address-Here

read -p "press ENTER continue"
read -n 1 -s -r -p "press any key to continue"

chmod u=rwx,g=rwx,o=rwx file.txt							// permissions

[command] &                                                 // run command and push to background
jobs                                                        // see commands pushed to background
disown                                                      // commands will continue running even when terminal closes

command | tee file1 file2 file3                             // output of command to console and each file

echo $(date '+%Y-%m-%d')                                    // formatted current date (old way)
printf '%(%Y-%m-%d %H:%M:%S)T' -1                           // formatted current date (new way)

command > /dev/null                                         // hide output
command > /dev/null 2>&1                                    // hide output and errors (redirects stderr to stdout, so errors (if any) also goes to /dev/null)

wc -l file.txt												// number of lines in a file
wc -l < file.txt											// outputs only the number

yum install lsof											// installing lsof command

return <n>
exit <n>

sed -i 's/\r//' file.txt									// line endings (win -> unix)

curl localhost:8080
curl localhost:9200 | json_pp								// prettify JSON
curl -v localhost:8080										// ?

curl -o out.json -H "Content-Type: application/json" localhost:9200/_search
curl -d @in.json -o out.json -XPOST -H "Content-Type: application/json" localhost:9200/_search
curl -d @in.json -o out.json -XPUT -H "Content-Type: application/json" localhost:9200/_search
curl -d @in.json -o out.json -XDELETE -H "Content-Type: application/json" localhost:9200/_search

ssh root@<ip>

adduser <username>
passwd

apt update
apt upgrade
apt install sudo

usermod -aG sudo <username>

--------------------------------
Debian 9 management
--------------------------------

# connect as root

ssh root@<ip>

# create non-root user

adduser <username>

# connect as user
# check sudo is installed

sudo apt update

# if not, connect as root

apt update
apt upgrade

# restart server
# connect as root
# install sudo

apt install sudo

# add user to sudo group

usermod -aG sudo <username>

--------------------------------
Open SSH
--------------------------------

ssh-keygen -t ed25519 -C "email@example.com"				// generate SSH key pair, key type ED25519, with comment, prompts for output file later
ssh-keygen -t rsa -b 4096 -C "email@example.com"

ssh -T git@gitlab.com										// replies with welcome message if your PubKey on server == some PubKey in your ~/.ssh key pairs

--------------------------------
bash prompt
--------------------------------

echo "Question?"
select yn in "Yes" "No"; do
    case $yn in
        Yes ) command-that-does-something; break;;
        No ) exit;;
    esac
done

--------------------------------
bash conditions
--------------------------------

// else if

if [[ $1 == "a" ]]; then
	...
elif [[ $1 == "b" ]]; then
	...
else
    ...
fi

--------------
negation
--------------

if ! [[ $? -eq 0 ]]; then
    ...
fi

--------------
multiple conditions
--------------

if [[ ( "$a" -eq 1 && "$c" = "123" ) || ( "$b" -eq 2 && "$c" = "456" ) ]]; then
    ...
fi

--------------
test for variable value
--------------

if [[ $VAR_SOME == 1 ]]; then
    echo "variable value is 1"
else
    echo "variable value is not 1"
fi

if [[ $VAR_SOME == "some_value" ]]; then
    echo "true"
else
    echo "false"
fi

--------------
test for number of arguments
--------------

if [ $# -eq 0 ]; then
    echo "No arguments supplied"
fi

--------------
test of argument existence (not tested)
--------------

if [ -z "$1" ]; then
    echo "No argument supplied"
fi

--------------
test for non-empty commands output
--------------

if [[ $(docker container ls -aq) ]]; then
    echo "there are containers"
else
    echo "there are no containers"
fi

--------------
test for folder existence
--------------

if [ -d "/folder" ]; then
    echo "exists"
else
    echo "does not exist"
fi

--------------
test for file existence
--------------

if [ -f "/file.txt" ]; then
    echo "exists"
else
    echo "does not exist"
fi

--------------
test for last commands success
--------------

if [[ $? != 0 ]]; then
    echo "last command failed"
else
    echo "last command succeeded"
fi

--------------
tests above combined
--------------

VAR_COMMAND=$(docker container ls -aq)
if [[ $? != 0 ]]; then
    echo "last command failed"
elif [[ $VAR_COMMAND ]]; then
    echo "last command succeeded, non-empty output"
else
    echo "last command succeeded, empty output"
fi
